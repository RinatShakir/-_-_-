numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] # записываем исходный массив
primes = [] # создаем пустой список primes
not_primes = [] # создаем пустой список not_primes

# ОПРЕДЕЛЕНИЕ ПРОСТЫХ ЧИСЕЛ:
# Простое число - это положительное число, которое больше 1.
# Простое число не имеет других положительных делителей, кроме единицы и самого числа.
for i in range(len(numbers)): # записываем первый цикл для простых (primes) чисел, где число i должно быть в пределах массива numbers, поэтому применяем len и функцию range для возврата внутри массива numbers.
    a = 0 # записываем индекс по массиву
    for j in range(2, (numbers[i] // 2 + 1)): # записываем внутри первого цикла второй цикл для j, позволяющий определить простые числа j в массиве по соответствующей формуле. Начианем с цифры 2, для возврата используем функцию range.
        # используем оператор // для целочисленного деления
        if (numbers[i] % j == 0): # при этом записываем условие, если остаток от деления простого числа, выявленного из массива, равен 0, то нужно будет переходить на проверку следующего индекса в массиве
            a = a + 1 # для перехода на следующий индекс в массиве.
        break # с функцией break даем возможность выйти из условного цикла if
    if (a == 0 and numbers[i] != 1): # задаем отдельное в 1-ом цикле for дополниетельное условие, что индекс равен 0 и также  число в массиве не равно 1, чтобы не начать новый массив primes с 1.
        primes.append(numbers[i]) # применяем фукнцию append для того чтобы каждый раз пробегаясь по циклу, добавлять новое ПРОСТОЕ число в конец нового массива Primes
print('Primes: ', primes) # выводим печать на экран нового массива с имененем Prime, который должны записать вне 1-го цикла, для того чтобы у нас отработал весь цикл по массиву numbers и только в конце напечатал новый массив.

# следующим этапом записываем программу для остальных НЕ ПРОСТЫХ чисел в массиве numbers.
for k in range(len(numbers)): # записываем первый цикл для НЕ простых (not_primes) чисел, где число k должно быть в пределах массива numbers, поэтому применяем len и функцию range для возврата внутри массива numbers.
    a = 0 # записываем индекс по массиву
    for l in range(2, k): # записываем внутри первого цикла второй цикл для l, позволяющий определить НЕ простые числа l в массиве numbers и пробежаться c помощью функции range для возврата внутри массива numbers и далее по соответствующей формуле. Начинаем с цифры 2.
        if numbers[k] % l == 0: # при этом записываем условие, что остаток от деления на число l будет равен нулю
            a = a + 1 # при соблюдении условия переходим на следующий индекс в массиве.
    if a >= 1: # задаем отдельное в 1-ом цикле for дополниетельное условие, что индекс должен быть больше или равен 1.
        not_primes.append(numbers[k]) # применяем фукнцию append для того чтобы каждый раз пробегаясь по циклу, добавлять новое НЕ простое число в конец нового массива Not Primes
print('Not Primes: ', not_primes) # выводим печать на экран нового массива с имененем Not Prime, который должны записать вне 1-го цикла, для того чтобы у нас отработал весь цикл по массиву numbers и только в конце напечатал новый массив.